# QISKit ACQUA - Variational Forms

QISKit Algorithms and Circuits for QUantum Applications (QISKit ACQUA) is a set of algorithms and utilities
for use with quantum computers. 
The *variational_forms* folder here contains trial wavefunction pluggable objects that may be used by algorithms

# Variational Forms

The variational form represents a trial wavefunction that may be used in an algorithm such as
[VQE](../../../qiskit_acqua#vqe). The following variational forms are supplied here:

* [RY](#ry)
* [RYRZ](#ryrz)
* [UCCSD](#uccsd)
* [SWAPRZ](#swaprz)


## RY

This trial wavefunction is layers of Y rotations with entanglements. The number of optimizer parameters this form
creates/uses is given by `num qubits * (depth + 1)`. The following allows a specific form to be configured:

* `depth`=*integer 1 to n*

  Circuit depth to use, default 3.

* `entanglement`=**full** | linear

  The variational form will use a circuit where the entanglement of qubits is either _full_ (meaning all-to-all,
  that each qubit is entangled to all the others), or _linear_ (being next-neighbor coupling meaning
  that each qubit is entangled only with the next one, if any).

* `entangler_map`=*dictionary of arrays*

  The *entanglement* parameter can be overridden by a map explicitly specified here if an entanglement map different
  from the one auto-generated by *entanglement* is desired. The form of the map is a dictionary that has a source qubit
  index as the key, with the corresponding value being a list of target qubit indexes to which the source qubit should
  be entangled,
  e.g. `{0: [1, 2], 1: [3]}`


## RYRZ

This trial wavefunction is layers of Y plus Z rotations with entanglements. The number of optimizer parameters this form
creates/uses is given by `num qubits * (depth + 1) * 2`.  See [RY](#ry) for configuration, as that applies to this form too.


## UCCSD

This trial wavefunction is a Unitary Coupled-Cluster Single and Double excitations. For more information see:
[P. Barkoutsos et al., arXiv:1805.04340](https://arxiv.org/abs/1805.04340).

The UCC expansion preserves the number of particles (electrons), meaning that the initial state should be prepared with the
desired number of electrons in the HF (Hartree Fock) state. For a neutral molecule, the number of electrons equals
the number of protons. Note that the implementation does not require the use of Trotter steps in the expansion of the
cluster operators: exp((T1+T2)-(T1+T2)^\dagger). As shown in
[P. Barkoutsos et al., arXiv:1805.04340](https://arxiv.org/abs/1805.04340),
the variational approach gives good accuracy with a single Trotter step.

Rather than allowing single and double excitations with all particles and all unoccupied orbitals an active space can
be defined where the particles and unoccupied orbitals can be restricted to a so called active space. This allows the
UCCSD to have a simpler form and correspondingly a shorter circuit. While simpler this will result in an approximation
to the true value, which may be acceptable depending on the active space chosen.    

The following allows a specific form to be configured:

* `depth`=*integer 1 to n*

  Circuit depth to use, default 1.
  Differently from the heuristic trial wavefunction approach, in UCCSD we do not need repetition of the circuit.

* `num_orbitals`=*integer*

  The total number of spin orbitals for which the variational form is to be created 

* `num_particles`=*integer*

  The total number of particles for which the variational form is to be created 

* `active_occupied`=*list of integers, optional, default None*

  This parameter is a list of occupied orbitals whose particles are to be used in the creation of single
  and double excitations. By default all occupied orbitals are used. Spin orbitals are as the diagram below.    
```
                 alpha or up electrons                          beta or down electrons
    /-------------------------------------------\   /-------------------------------------------\
    0      1           No-1 No           No+Nv-1  No+Nv                                 2(No+Nv)-1
    \---------------------/\--------------------/   \--------------------/\---------------------/
             occupied             virtual                  occupied                virtual
             
    0---------------------n 0-------------------m
        active_occupied       active_unoccupied
             range                  range 
```
  The numbers in this list are orbital indices from 0 to n-1 where n orbitals are occupied. We need only to supply
  the index of the alpha orbitals as the beta can be computed. Indices can be given with negative numbers in
  which case -1 is the highest occupied orbital, -2 the next one down and so on.  

* `active_unoccupied`=*list of integers, optional, default None*

  This parameter is a list of unoccupied orbitals to be used in the creation of single and double excitations.
  By default all unoccupied orbitals are used. Particles from active_occupied are only allowed to be excited into
  orbitals defined by active unoccupied list.      

  The numbers in this list are orbital indices from 0 to m-1 where m orbitals are unoccupied. We need only to supply
  the index of the alpha orbitals as the beta can be computed. Indices can be given with negative numbers in
  which case -1 is the highest unoccupied orbital, -2 the next one down and so on.

* `qubit_mapping`=jordan_wigner | **parity** | bravyi_kitaev

  The mapping that is used from fermion to qubit. Note: bravyi_kitaev is also known as binary-tree-based qubit mapping. 

* `two_qubit_reduction`=**true** | false

  Whether two-qubit reduction is being used. Only valid with parity mapping, otherwise ignored

* `num_time_slices`=*integer, default 1*

  Number of time slices: non-negative integer


## SWAPRZ

This trial wavefunction is layers of swap+Z rotations with entanglements. It was designed principally to be a particle
preserving variational form for chemistry and is optimally used in conjunction with jordan_wigner mapping and
HartreeFock initial state. The number of optimizer parameters this form creates/uses is given by
`num_qubits + depth * (num_qubits + sum([len(v) for k, v in self._entangler_map.items()]))`.
The following allows a specific form to be configured:

* `depth`=*integer 1 to n, default 3*

  Circuit depth to use, default 3.

* `entanglement`=**full** | linear

  The variational form will use a circuit where the entanglement of qubits is either _full_ (meaning all-to-all,
  that each qubit is entangled to all the others), or _linear_ (being next-neighbor coupling meaning
  that each qubit is entangled only with the next one, if any).

* `entangler_map`=*dictionary of arrays*

  The *entanglement* parameter can be overridden by a map explicitly specified here if a entanglement map different
  from the one auto-generated by *entanglement* is desired. The form of the map is a dictionary that has a source qubit
  index as the key, with the corresponding value being a list of target qubit indexes to which the source qubit 
  should be entangled,
  e.g. `{0: [1, 2], 1: [3]}`


# Developers

New variational forms may be added programmatically and dynamically discovered by the QISKit ACQUA.
See [Developers](../../../qiskit_acqua#developers) section in algorithms readme for further information.

A new variational form should extend the variational_form class. A schema should define the configuration of this new
variational form. See the existing forms for examples. When the variational form is used and run the init_args will be
called with parameters as per the schema. The number of qubits will also be supplied and this should be the parameter
following self in the method argument list. During the initialization in init_args the variational form should set the
number of parameters it has and the bounds of these e.g.
``` 
   self._num_parameters = num_qubits * (depth + 1)
   self._bounds = [(-np.pi, np.pi) for _ in range(self._num_parameters)]
```
These values will later be used by VQE in conjunction with the optimizer. The variational form can also
indicate a preferred initial point. VQE will take an optional initial point from the user, if the user does not supply
one the it will look to the variational form for a preferred value. If this returns none then a random point will be
generated within the parameter bounds set, as per above. Finally should the variational form return `(None, None)` then
VQE will generate a random point assuming bounds of -2*pi and 2*pi.
